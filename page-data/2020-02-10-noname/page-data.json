{"componentChunkName":"component---src-templates-post-template-js","path":"/2020-02-10-noname/","result":{"data":{"post":{"id":"ff17a79d-7cfc-5757-874a-def537f62edf","html":"<h3>Reactor 특징</h3>\n<ul>\n<li>리액티브 스트림즈의 구현체인 <code class=\"language-text\">Reactor</code> 는 리액티브 프로그래밍을 위한 라이브러리이며,\nReactor Core 라이브러리는 Spring WebFlux 프레임워크 라이브러리로 포함되어 있다.</li>\n<li>\n<p>Flux[N]</p>\n<ul>\n<li>Reactor 의 Publisher 타입은 크게 두 가지인데, 그중 한가지이다.</li>\n<li>Flux[N] 이라는 의미는 N 개의 데이터를 emit 한다는 것인데, 다시 말해서 Flux 는 0 개부터 N개, 즉 무한대의 데이터를 emit 할 수 있는\nReactor 의 Publisher 이다.</li>\n<li>Publisher 가 Subscriber 에게 데이터를 전달하는 것을 일컬을 때 데이터를 ‘통지(발행, 게시, 방출)한다’라고 하는데 이런 용어들의 공통점은\n입력으로 들어오는 데이터를 제공한다라는 의미이다.</li>\n<li>리액티브 관련 문서를 보면 Emit 이라는 용어를 많이 볼 수 있는데 우리말로 해석하면 ‘방출하다’, ‘데이터를 내보내다’ 정도로 이해하면 될 것 같다.</li>\n</ul>\n</li>\n<li>\n<p>Mono[0|1]</p>\n<ul>\n<li>Reactor 의 두번째 Publisher 타입이다. Mono 는 데이터를 한 건도 emit 하지 않거나 단 한건만 emit 하는 단발성\n데이터 emit 에 특화된 Publisher 이다.</li>\n</ul>\n</li>\n<li>\n<p>Backpressure-ready network: Reactor 는 Publisher 로부터 전달 받은 데이터를 처리하는 데 있어 과부하가 걸리지 않도록 제어하는\nBackpressure 를 지원한다.</p>\n<ul>\n<li>우리말로는 ‘배압’이라고 하는데 가스나 액체 등의 흐름을 제어하기 위해 역으로 가해지는 압력을 의미한다.</li>\n<li>비슷한 맥락으로 Publisher 로부터 전달되는 대량의 데이터를 Subscriber 가 적절하게 처리하기 위한 제어 방법이 바로 Backpressure 이다.</li>\n</ul>\n</li>\n</ul>\n<h3>Mono&#x3C;List&#x3C;T>> 와 Flux&#x3C;T> 의 차이점은?</h3>\n<ul>\n<li>Mono 와 Flux 에 대해 처음 접했을 때 Flux 는 N 개의 데이터를 받을 수 있고, Mono&#x3C;List&#x3C;T>> 로 리스트로 여러건의\n데이터를 받을 수 있으니까 같은게 아닌가? 라는 생각이 들었다. 차이점을 정리해보면 다음과 같다.</li>\n<li>Flux 는 각 데이터 항목을 개별적으로 처리하는 반면 Mono&#x3C;List&#x3C;T>> 는 리스트 전체를 단일 데이터 항목으로 처리한다. 이는 Flux 에서는 각 항목에\n대한 처리가 병렬적이거나 비동기적으로 이루어질 수 있지만, Mono&#x3C;List&#x3C;T>> 에서는 리스트 전체에 대한 처리가 한 번에 이루어진다는 것을 의미한다.</li>\n<li>Flux 는 backpressure 를 관리하는데, 이는 subscriber 가 처리할 수 있는 속도에 맞춰 데이터를 제공하는 것을 의미한다. 하지만 Mono&#x3C;List&#x3C;T>>\n는 리스트 전체에 대한 처리가 한 번에 이루어진다.</li>\n<li>Flux 는 여러 데이터 항목에 대해 여러 개의 onNext 시그널을 발생시키고, 마지막에 onComplete 혹은 onError 시그널을 발생시킨다. 반면 Mono&#x3C;List&#x3C;T>>\n는 단일 데이터 항목(List&#x3C;T>)에 대해서만 onNext 시그널을 발생시키고, 마지막에 onComplete 또는 onError 시그널을 발생시킨다.\n이 부분은 아래의 마블 다이어그램을 보면 조금 더 쉽게 이해 할 수 있다.</li>\n<li>\n<p>요약</p>\n<ul>\n<li>Flux 는 데이터 스트림을 통해 개별적이고 연속적인 데이터 처리를 제공하는 반면, Mono&#x3C;List&#x3C;T>> 는 단일 단위로 전체 데이터 세트를 처리한다.</li>\n<li><strong>Flux 는 T 타입의 데이터가 각각 발행되고, Subscriber 가 이를 받을 수 있고, Mono&#x3C;List&#x3C;T>> 는 List&#x3C;T> 가 모두 준비되어야지만\n이를 발행하고 Subscriber 가 받을 수 있다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3>Hello Reactor 코드로 보는 Reactor 의 구성요소</h3>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Flux<span class=\"token punctuation\">.</span><span class=\"token function\">just</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Reactor\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span><span class=\"token function\">lowercase</span><span class=\"token punctuation\">(</span>Locale<span class=\"token punctuation\">.</span><span class=\"token function\">getDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token operator\">::</span>println<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>Flux 는 Reactor 에서 Publisher 의 역할을 한다. 예제에서 Flux 대신 Mono 를 사용할 수도 있고, 이때는 하나의 데이터만을 Mono.just() 로\nPublish 할 수도 있다.</li>\n<li>subscribe 메서드의 파라미터로 전달된 메소드 참조인 ::println 이 Subscriber 역할을 한다.</li>\n<li>just, map 은 Reactor 에서 지원하는 Operator 메서드인데, just() 는 데이터를 생성해서 제공하는 역할, map() 은 전달받은 데이터를\n가공하는 역할을 한다.</li>\n<li>크게 보면 <strong>데이터를 생성해서 제공하고(1단계), 데이터를 가공한 후에(2단계) 전달받은 데이터를 처리한다(3단계)는 3단계를 거친다.</strong></li>\n</ul>\n<h3>마블 다이어그램(Marble Diagram)</h3>\n<ul>\n<li>마블은 우리말로 구슬이라는 의미가 있고, 다이어그램은 여러 가지 도형들로 그려진 도표를 뜻한다. 즉, 여러 가지 구슬 모양의 도형으로 구성된 도표로,\n비동기적인 데이터 흐름을 시간의 흐름에 따라 시각적으로 표시한 다이어그램이다. 근데 처음 마블 다이어그램을 보면 이게 뭔가 싶다… 오히려 이것 때문에\nReactor 에 접근하기가 더 어렵지 않나 개인적으로 생각한다. 그래도 다이어그램을 읽을 수 있으면 삽질을 조금이라도 덜 할 수 있으니 하나하나 살펴보도록 하자.</li>\n</ul>\n<br>\n<ul>\n<li>마블 다이어그램은 크게 두 개의 타임라인과 Operator 로 구성되어 있다.</li>\n<li>상단의 타임라인은 Publisher 가 데이터를 emit 하는 타임라인이고, 왼쪽에서 오른쪽으로 시간이 흐르는 것을 의미하기 때문에\n가장 왼쪽에 있는 구슬이 시간상으로 가장 먼저 emit 된 데이터이다.</li>\n<li>가운데 박스는 Publisher 로부터 전달받은 데이터를 처리하는 Operator 함수이다. Operator 마다 다양한 마블 다이어그램을 가진다.</li>\n<li>하단의 타임라인은 Operator 함수에서 가공 처리되어 출력으로 내보내진 타임라인이다.</li>\n<li>| 는 처리되는 요소들의 정상적인 완료를 의미한다.</li>\n<li>❌ 표시는 에러가 발생해 데이터 처리가 종료되었음을 의미하며, onError Signal 에 해당된다.\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/85c57af7056e02809887a9e3edf1b321/ee9b6/marble-diagram.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 43.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtUlEQVR42oWSXYvTQBSG++O99d4bRRQF92rBioh3LqKCrI27uq26bbdpN2nqZCYfk7TNJI9nWiKIgi+ciyHn83kz6LqOPrzatkVrQ2UrerXOYYwh1RqlFE5yvPqaXv494B8qsoTtrpZGe8lybBuHrUrKzQqbKZptRds0h9yqqjBZRlnaw3vgZLqfqtKUpqllHXg5ekiwPCf5+oRs+ZZHFwmfohB1/4qfwZrs9A7Tsxcsb0Pi6Jbp9Q9ms2upb44b+jN/n952xJtIpmq0WmNLg8ot1hpMtKZMN6johmi5oCq1FG/BWalzeAKDTNb1oYWPZ2XLnDzPpYE9nBOGIaNRwOdgxGL+nV1dHL4byS+K4m+GdV3TR9e10ihnX7c0O0e1A6Vz1uGcKJyR2kgMKSgErRU0dV3imr0Ylgnz3ZFhD9aKq217BH364QHBzTmri2eo8D0nlzGj1YLbx5esPy6Int9lenKPfBOzFYO+TcaycXps6Pn5k/O8kGmeB5xNhkyiK8z8NVkc8GqqGSdixnCM/rKifPcU82bIRkw5MpRfTK7r+g3/L0eaJCRFTKJimj+49YYeXvwCqUWtqD7NT+8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"marble-diagram\"\n        title=\"\"\n        src=\"/static/85c57af7056e02809887a9e3edf1b321/5a190/marble-diagram.png\"\n        srcset=\"/static/85c57af7056e02809887a9e3edf1b321/772e8/marble-diagram.png 200w,\n/static/85c57af7056e02809887a9e3edf1b321/e17e5/marble-diagram.png 400w,\n/static/85c57af7056e02809887a9e3edf1b321/5a190/marble-diagram.png 800w,\n/static/85c57af7056e02809887a9e3edf1b321/ee9b6/marble-diagram.png 1041w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>아래의 다이어그램은 정상적으로 데이터 방출이 완료된 경우와 중간에 cancel 된 경우를 보여준다.</li>\n<li>왼쪽은 세개의 데이터중 하나의 데이터만 Operator 를 통과 하고 complete signal 이 방출된다는 것을 의미한다.</li>\n<li>오른쪽은 두 번째 데이터가 들어오고, cancel 신호를 전달하는 경우를 보여준다. 이때 두 번째 데이터만 방출하고, 그 뒤의 데이터는 요청하지 않고\ncomplete signal 이 방출된다는 것을 의미한다.\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b6feaafe896e8fc3bd743dc32108be5b/d7ba6/two-cases-of-sources.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 42%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbElEQVR42mVR226DMAzl/79ib/uCSXve5WWTpk1jXaEqawsUSqFQaMidMwepXdtZchI7to997OFKhuHaHi7UieACqzhGnudYr9dI0xRlWUJKCY8xhq7r0LYttFYUbqGNgNQc1lr8F4tD36Kpa3TtHrsqR0v5LtYBelEUwfc/sVwuoZUA6wVe5894er9B+P2Al+UWRb5GtavG7v14gvuPW9SrRxTVBjX5XYda6xHOa5oGRVFQlwcyNQrGwelTSkbagwk1jmKNAVMGJQE6vyKV5LN2gFLqRIeXZRnCMEQU/aDbN9hTEhcS7MAI1VCihBBiDDakjA5FdrU/gFPsOenjyO44zu+QHB+uwGw2Iyp8BNMpJpMJ5vM5giBASH53tzSRIDDHvTHmr+D1RjnnY0FHRUZbXMUJFosFqqoaN3m8izzBdruleEF59rLDc3XF+r7HYDTSusPbaoMsSUafE8enUhJpcIcw+KK3PhVz8guOsmZ7IXR7CAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"two-cases-of-sources\"\n        title=\"\"\n        src=\"/static/b6feaafe896e8fc3bd743dc32108be5b/5a190/two-cases-of-sources.png\"\n        srcset=\"/static/b6feaafe896e8fc3bd743dc32108be5b/772e8/two-cases-of-sources.png 200w,\n/static/b6feaafe896e8fc3bd743dc32108be5b/e17e5/two-cases-of-sources.png 400w,\n/static/b6feaafe896e8fc3bd743dc32108be5b/5a190/two-cases-of-sources.png 800w,\n/static/b6feaafe896e8fc3bd743dc32108be5b/d7ba6/two-cases-of-sources.png 1107w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<h3>Reference</h3>\n<ul>\n<li>스프링으로 시작하는 리액티브 프로그래밍</li>\n<li><a href=\"https://projectreactor.io/docs/core/release/reference/#howtoReadMarbles\">How to read marble diagrams?</a></li>\n<li><a href=\"https://medium.com/@jshvarts/read-marble-diagrams-like-a-pro-3d72934d3ef5\">Understanding Marble Diagrams for Reactive Streams</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/2771091\">flatMap 만 사용하기는 그만! Reactor 오퍼레이터 파헤치기</a></li>\n</ul>","fields":{"slug":"/2020-02-10-noname/","prefix":""},"frontmatter":{"title":"Reactor 개요와 마블다이어그램","category":"spring-reactive"}},"authornote":{"id":"265dda60-7971-5464-926f-ea569c79ac0a","html":"<p>🔘 안되면 될 때 까지! 🏃 🔘</p>"}},"pageContext":{"slug":"/2020-02-10-noname/","next":{"id":"97ef9455-cc2f-5153-8a4c-65727266bf14","fields":{"slug":"/gradle-project-setting/","prefix":"2019-02-10","source":"posts"},"frontmatter":{"title":"gradle 멀티 프로젝트 세팅하기","category":"build-tool"}},"source":"posts"}},"staticQueryHashes":["960164547","960164547"]}