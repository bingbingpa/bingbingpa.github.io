{"componentChunkName":"component---src-templates-post-template-js","path":"/postgresql-high-availability/","result":{"data":{"post":{"id":"169dc29c-faf5-5fda-a89b-b110feb1b9fa","html":"<h3>1. 정의</h3>\n<ul>\n<li>고가용성(HA, High Availability)이란 서버와 네트워크, 프로그램 등의 정보 시스템이 상당히 오랜 기간 동안 지속적으로 정상 운영이 가능한 성질을 말한다.</li>\n<li><strong>데이터를 수정할 수있는 서버</strong>를 read/writer, <strong>master</strong>, primary server 라고 한다.</li>\n<li><strong>master 의 변경 사항을 추적 하는 서버</strong>를 <strong>standby</strong>, secondary server 라고 한다.</li>\n<li><strong>마스터 서버로 승격 될 때까지 연결할 수없는 대기 서버를 warm standby server 라고 하며, 연결을 허용 하고 읽기 전용 쿼리를 제공 하는 서버를 hot standby server 라고 한다.</strong></li>\n<li>일부 솔루션은 동기식이므로 모든 서버가 트랜잭션을 커밋 할 때까지 데이터 수정 트랜잭션이 커밋 된 것으로 간주되지 않는다. 이렇게하면 장애 조치 (failover)시 데이터를 잃지 않고 모든 부하 분산 서버가 쿼리 한 서버에 상관없이 일관된 결과를 반환한다.</li>\n<li>반대로 비동기 솔루션을 사용하면 커밋 시간과 다른 서버로의 전파 사이에 약간의 지연이 발생하여 백업 서버로 전환 할 때 일부 트랜잭션이 손실 될 수 있으며, 로드 밸런싱 된 서버가 약간 오래된 결과를 반환 할 수 있습니다. 비동기 통신은 동기화가 너무 느릴 때 사용된다.</li>\n</ul>\n<h3>2. 여러 해결 기법 비교</h3>\n<ul>\n<li>\n<p>Shared Disk Failover</p>\n<ul>\n<li>하나의 디스크에 여러개의 Postgres 인스턴스를 사용하며, master 서버가 망가지면 대기하던 서버가 해당 디스크를 마운트해서 사용한다.</li>\n<li>master 서버가 실행 중일 때 대기 서버가 공유 스토리지에 절대 액세스하지 않아야 한다.</li>\n<li><strong>고가의 SAN 스토리지를 사용 하거나 그보다 좀 저렴한 iscsi 스토리지를 사용한다.</strong></li>\n<li><strong>NAS 기반 nfs 파일 시스템을 데이터 저장 공간으로는 절대로 사용하지 않는 것이 관례이다.</strong> nfs 파일 시스템은 잦은 읽기 쓰기 환경에서는 속도와 안전성을 보장하지 않기 때문이다.</li>\n</ul>\n</li>\n<li>\n<p>File System(Block Device) Replication</p>\n<ul>\n<li>파일 시스템 레벨의 복제</li>\n<li>standby 서버에 대한 write 는 master 서버와 동일한 순서대로 수행 되어야 한다.</li>\n<li>주로 DRBD(Distributed Replication Block Device) 라는 Linux 용 파일 시스템 복제 솔루션을 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>Write-Ahead Log Shipping</p>\n<ul>\n<li>WAL : 데이터 무결성을 보장하는 표준 방법이며, 데이터베이스의 변경 내용을 기록하는 파일이다. wal 파일은 pg_waldump 명령어로 읽을 수 있다.\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4fca4fcb804a434241cc69d6cb1ae075/fe238/wal-file.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 26%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAxElEQVR42k2QR27AMAwEfffBvfcGd9j//9wGw8BBDguKpDhcyVmWRWVZqus6tW2roigsj+NYfd/reR7N86x1Xa3PmZjnuZIkUZqmJs6+78vhQhAEGoZBVVWpaRqDRlFkwPu+NY6jgadp0nmeliP627bZMnI4DpcYxuF/IA6pAWTZF/d9t4gAHsdh0D8gDsMwtEJd1yaAPIGhz9n7vvZcwETEzHVdJu56nvfrMMsyc0bELWIJYPo4/+L3NYi/xiU1DLiuqx/0UoeUtQwBQAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"walFile\"\n        title=\"\"\n        src=\"/static/4fca4fcb804a434241cc69d6cb1ae075/5a190/wal-file.png\"\n        srcset=\"/static/4fca4fcb804a434241cc69d6cb1ae075/772e8/wal-file.png 200w,\n/static/4fca4fcb804a434241cc69d6cb1ae075/e17e5/wal-file.png 400w,\n/static/4fca4fcb804a434241cc69d6cb1ae075/5a190/wal-file.png 800w,\n/static/4fca4fcb804a434241cc69d6cb1ae075/c1b63/wal-file.png 1200w,\n/static/4fca4fcb804a434241cc69d6cb1ae075/fe238/wal-file.png 1401w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li><strong>WAL(트랜잭션 로그)를 스트리밍이나 파일 기반으로 전달해서 standby 서버를 동기화 한다.</strong></li>\n<li><strong>standby 서버를 hot standby server(읽기 전용 쿼리를 제공 하는 서버)로 만들어 추가적으로 활용 할 수 있다.</strong></li>\n<li>\n<p>WAL file log shipping : WAL 파일 자체를 standby 서버로 전송한다.(file copy)</p>\n<ul>\n<li>master 서버에 지정된 WAL 파일의 크기를 다 채워야 standby 서버로 전송이 일어나기 때문에, 만약 WAL 파일을 다 채우지 못한 상태에서 master 서버에 장애가 발생하면 WAL 파일을 다 채우지 못해서 전달되지 못한 로그는 유실된다.</li>\n</ul>\n</li>\n<li>\n<p>streaming log shipping : WAL 파일 저장 여부와 관계 없이 로그 내용을 standby 서버로 직접 전달한다.</p>\n<ul>\n<li>master, standby 서버간의 네트워크에 문제가 없다는 가정하에 거의 실시간으로 동작한다.</li>\n<li>wal<em>keep</em>segements 값에 따라 WAL 파일의 저장 개수가 정해지는데, standby 서버에 장애가 발생할 경우 만약 이 값이 32라면 master 서버에서 33번째 WAL을 쓰기 시작하면 1번째 파일은 유실되고, standby 서버가 다시 동작하더라도 데이터를 동기화 하는 방법은 다시 구축하는 방법 밖에는 없다.</li>\n<li>위와 같은 상황을 방지하기 위해서 standby 서버로 보낼 WAL 파일을 그냥 버리지 않고, 별도의 공간에 저장 후 standby 서버에 장애가 발생했을 경우에 <a href=\"https://www.postgresql.org/docs/12/runtime-config-wal.html#GUC-RESTORE-COMMAND\">restore command</a> 를 사용하여 복구 할 수 있다. 단, 별도의 저장공간이 필요하다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Logical Replication</p>\n<ul>\n<li>변경된 데이터를 스트림으로 다른 서버로 보내며, 테이블 단위로 리플리케이션 될 수도 있다.</li>\n<li><strong>N : N 의 구독자(subscribers) 와 게시자(publishers) 모델을 사용한다.</strong></li>\n<li>일반적으로 게시자 데이터의 스냅샷을 만들어서 구독자에게 복사하는 것으로 리플리케이션이 시작되고 게시자의 변경 내용이 실시간으로 구독자에게 전송되어 게시자와 동일한 순서로 데이터를 적용한다.</li>\n<li>\n<p>활용 사례</p>\n<ul>\n<li>N 대의 서버가 게시자가 되고 1대의 서버가 구독자가 되어 여러 서버의 정보를 하나의 서버로 모아서 분석 목적으로 사용.</li>\n<li>논리적인 형태의 복제이기 때문에 다른 플랫폼 postgres 인스턴스간의 복제(Linux -> Windows) 가능.</li>\n</ul>\n</li>\n<li>구독자가 읽기 전용으로 사용되는 경우 충돌이 발생하지 않지만, 구독자가 동일한 테이블에 대한 쓰기를 수행하면 충돌이 발생할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Trigger-Based Master-Standby Replication</p>\n<ul>\n<li>데이터 변경을 주 서버가 받아서 처리하고 비동기적으로 복제 서버에 보낸다.</li>\n<li>테이블 단위로 컨트롤 가능</li>\n<li>master 서버가 실행중인 동안 standby 서버는 hot standby 서버로 읽기 전용 조회에 응답 할 수 있고 여러 대의 standby 서버를 지원한다.</li>\n<li>대기 서버를 비동기식으로 (일괄 적으로) 업데이트 하므로 장애 조치 중에 데이터가 손실 될 수 있다.</li>\n<li>DDL replication 은 지원하지 않는다.</li>\n</ul>\n</li>\n<li>\n<p>Statement-Based Replication Middleware\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5c836a58a71dfa57552d61c83a39f1ea/6783b/pg-pool.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 235px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 87.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7DAAAOwwHHb6hkAAADAElEQVR42m1TWU8TYRTtz/HJX6D/QH+CD6IxGre4YHg0wRiIUcQgETUhMRojLyaY2IBSAkYEOl2wLe20FLpP92k7087aOd7ZSovc5OZbcu75zl0+D8gMw0C/b5hbfN/K49ozBhNv9vBgLoz75OPzYdycCeIW+e2XQdx9FcLVaT9+hctWjBlrcpjmcQl1h3D+axJnx3yYWIjhxouw5ffmIrgyHcTlqaC1jpGfufQTS2sZK0bXTyF0Fa4xJTx8HcLTD1HLZ77ESVkAd2aDeP45julP+5j6GLMw29HK6Qpdcy+HLZ7tIFUQkMoLSND+pJ2M8ZgXA3decy3A8jgoioNzuiSCSfADEhc7zOEZecHZGwT0x5so1aVBoBtc5WXs7DcgK/pIjEtspawSWNL6kKm4fFfDxt86Sk15VMVQenVBxfpeHRyRq4Ydq+hODXlZB1OVkRN1ZIksTPUKlSXa64g1FBy21YGCJmF3KxI42QBLD+4ctZGlOJZXEG0qyAkaPEVRRVkB2FQGjxeWMfluGbGUPQ6iqiNOYNdyHRUNDTg4ymPy7TKevP+GCGtjW/RYih73cETI94HfTAznrs/h4qNFMBHWJlTM148VFijVDmUWiKRwnrAXxhcRjCYHhGmTsNLTkBftAns36YfMLkHqCta5q/aRGFJYFDVwPRv7YytsYXsOtq04hFUCZNoyup0WRIFmjtJpCDJ1uo+eZowQlqiuRVLZI1yn3bKw9Y49CYJquAp1UqhBaPFgmABS6QzVMIu+3oeknyTULK+VOaTTaeQKJeS4Bvgmj/ZwyjkrZQPrG5vwer1E7Hea8n/KFerwfjQCfyAAn8+HldUVrK6s4JCr0mQYtsKyU5diLovMQcparU9PM8i2hgmpgdRlVWxj988WYnshhJhdHCUTUKixlkKOUtim2TJTKfQM5HuUmmQgS7ViWypizWPCAikM1GSrRCUqnYktSvZ9lGY2SXiPRirMxtQkckq/YtaI1iqdzfsu/QLXzB9Vc+5dbJVW887MskfYf/8Q6pFXLHFXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"pg-pool\"\n        title=\"\"\n        src=\"/static/5c836a58a71dfa57552d61c83a39f1ea/6783b/pg-pool.png\"\n        srcset=\"/static/5c836a58a71dfa57552d61c83a39f1ea/772e8/pg-pool.png 200w,\n/static/5c836a58a71dfa57552d61c83a39f1ea/6783b/pg-pool.png 235w\"\n        sizes=\"(max-width: 235px) 100vw, 235px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<ul>\n<li><strong>미들웨어 프로그램이 모든 SQL 쿼리를 가로 채서 하나 또는 모든 서버로 보내며, 각 서버는 독립적으로 작동한다.</strong></li>\n<li>모든 서버가 변경 사항을 수신 할 수 있도록 읽기 / 쓰기 쿼리를 모든 서버로 보낸다.</li>\n<li>읽기 전용 쿼리는 단 하나의 서버로 전송해서 서버간 부하를 줄일 수 있다.</li>\n<li>각 서버는 독립적으로 작동 하기 때문에 브로드 캐스트 시 random(), CURRENT_TIMESTAMP, sequence 와 같은 값은 각 서버마다 다를 수 있다.</li>\n<li>\n<p>모든 서버의 값을 동일하게 갖기 위한 방법1</p>\n<ul>\n<li>어플리케이션이 단일 서버에서 값을 조회해서 쓰기에 사용한다.</li>\n</ul>\n</li>\n<li>\n<p>모든 서버의 값을 동일하게 갖기 위한 방법2</p>\n<ul>\n<li>미들웨어는 데이터 수정 쿼리만 master 서버로 전송하고, 미들웨어가 아닌 일반적인 마스터 대기 복제를 통해 대기 서버로 전파한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>주의 사항</strong></p>\n<ul>\n<li><strong>한 서버에서 트랜잭션이 시작되어 커밋 되었다면, 다른 모든 서버에서도 모두 커밋되어야 그 트랜잭션이 유효하다고 처리되어야한다.</strong></li>\n<li><strong>특정 서버에서 롤백된다면, 그 트랜잭션은 모든 서버에서 롤백되어야한다.</strong></li>\n<li>이것을 구현하기 위해서는 미들웨어가 2중 커밋(two-phase commit)을 이용한다.(postgreSQL의 PREPARE TRANSACTION, COMMIT PREPARED 명령)</li>\n</ul>\n</li>\n<li>Pgpool-II 및 Continuous 텅스텐 은 이러한 유형의 복제에 해당한다.</li>\n</ul>\n</li>\n<li>\n<p>Asynchronous Multimaster Replication</p>\n<ul>\n<li>비동기 멀티 마스터 복제는 시간차를 두고 서로 통신하게 된다.</li>\n<li>데이터가 충돌이 나면 사용자가 해결 할 수 있는 방법을 제공하거나, 충돌 해결 정책에 따라 자동으로 해결 할 수 있는 기능이 있어야 한다.</li>\n<li>Bucardo 라는 제품이 있다.</li>\n</ul>\n</li>\n<li>\n<p>Synchronous Multimaster Replication</p>\n<ul>\n<li>동기식으로 작업하기 때문에 자료 변경이 빈번한 환경이라면, 단독 운영 서버 환경 보다 성능이 더 떨어질 수 있다.</li>\n<li>PostgreSQL에서는 이 방식의 복제 기능은 제공하지 않는다.</li>\n</ul>\n</li>\n<li><strong>기능 비교 표</strong>\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/685990b920f16562567bfee5b07d6336/9eaa0/table.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 42%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBnbm9tZS1zY3JlZW5zaG907wO/PgAAARNJREFUeNpVUccOhTAM6/9/G3ckODAkhhgFWvbKqyOCeEhR2jSxHaPIfed50jzPOFLbtpSmKeV5TnEcU+PuYRiStZbrZVmS53lcQ/i+z/UgCLhfGWNomia6rovu+6bjOGjbNtr3nUmsey+Kgvq+pyRJmDDLMmqahuq65jve1nWlZVlIgXFxF4DhQ3EYBiYBGe4YEoUY7rqOAUCMPhDrB1iBFQq07l4AUbg+RFCNDVCTDQ53RkYP6gBmhWATVjQj4CkAkBEY/GbpkSyBGQXz4YnW+n0Ao5zN4yEI0YtNGMjF/hEgmRXCM2QBEqUIaw17OI4je8XrPm9iwVeEiqKI/15VVa9f0ogs/oh3WAu+Ccifry7/ALITaJ42Ycf6AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"table\"\n        title=\"\"\n        src=\"/static/685990b920f16562567bfee5b07d6336/5a190/table.png\"\n        srcset=\"/static/685990b920f16562567bfee5b07d6336/772e8/table.png 200w,\n/static/685990b920f16562567bfee5b07d6336/e17e5/table.png 400w,\n/static/685990b920f16562567bfee5b07d6336/5a190/table.png 800w,\n/static/685990b920f16562567bfee5b07d6336/c1b63/table.png 1200w,\n/static/685990b920f16562567bfee5b07d6336/29007/table.png 1600w,\n/static/685990b920f16562567bfee5b07d6336/9eaa0/table.png 1676w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<h3>3. Write-Ahead Log Shipping</h3>\n<ul>\n<li>PostgreSQL Streaming Replication 은 기본이 비동기 방식이다.</li>\n<li>동기식 복제 방식은 하나의 트랜잭션을 하나 이상의 standby 서버에 반영하고, 그 결과를 master 서버가 확인하는 방식이며, master, standby 서버 모두 트랜잭션이 트랜잭션 로그 파일에 기록 되었을 경우에만 정상처리 되었다고 판단한다.</li>\n<li>동기식 복제 방식은 자료의 안정성을 제공하지만, standby 서버의 작업 완료 응답을 확인하는 작업까지 포함하므로 그 만큼의 지연시간이 생길 수 밖에 없다.</li>\n<li>기본적인 WAL 파일을 이용한 복제는 다음과 같은 방식으로 동작하며, 본 글에서는 기본적인 streaming replication 을 설정하는 방법에 대해서만 다룬다.\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/366f968c72623e9599f20b816683ef95/cc155/wal-log-shipping.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 23%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABHElEQVR42m2QyU7CYBSF+6DGjb6PPoM7FxrjggCxRIQ0EYIJiYDiQBhKLe3f0gk6f/6hbjSe5OTm5M5HSYEwgyAtZCzxkoIDyow02VMW2UG6cU6Ugy/r3NcpzmRClOb8hbJYLInCsFKyebvL6D273HVnNDsfqNqcpxeXIKkGO7bN+ekx5ydHNLtjLD8jS2P2cUwsqZxd1Ni4Aba1oa2qzE2L1mjIdadFra9RHzwyMnRWpo3aaKAvF1zW77lqtHg3AoZTE8cR2HKREAJFCAc/iA5XBlsXM4q4Xfe4WWkV1xptMcaPU7aOQ5bseOhPGIw+edM9TBH+ftnbJ8y/LHTbZSctCaSP/8FLS+lzzmxtMtMNDPlV/JMripKyrPgNH3pzaAQ3lYwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"log-shipping\"\n        title=\"\"\n        src=\"/static/366f968c72623e9599f20b816683ef95/5a190/wal-log-shipping.png\"\n        srcset=\"/static/366f968c72623e9599f20b816683ef95/772e8/wal-log-shipping.png 200w,\n/static/366f968c72623e9599f20b816683ef95/e17e5/wal-log-shipping.png 400w,\n/static/366f968c72623e9599f20b816683ef95/5a190/wal-log-shipping.png 800w,\n/static/366f968c72623e9599f20b816683ef95/cc155/wal-log-shipping.png 886w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<h4>3.1. postgresql 9.6 / 12 차이점 비교</h4>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b5891c01fbeeaf9fbd8417febd57ccac/6da96/change-list.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 25.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA+0lEQVR42jVP26qCABD0/38nETQvqJGK1zQSNLW8UGKiFfg6sXs4D8Msu7M7O4Jt29jtdhBFEbIsQ1VV5v1+z3w4HOD7PhzHAWmprygKs+u6PCOmvePxCKEoCgRBAMuyEEURmqbB4/FA27YsPp1OuN/veD6fjHEckec5PM9DVVWsu91u6Pser9cLQlmWCMMQSZLwATKYpomPZlnGSNMUpLter7xETAdphwzP5zObDMPw92Ecxzy4XC7ouo4/IneKpWkaTNNkUCT6hPSSJEHXdZ4bhsGmdV1DoBhU/Lt/Ph/GPM8c5/1+Y11XZup/v1/+nlJQn7AsC/e3bcMP+MFeHWQsbDMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"change-list\"\n        title=\"\"\n        src=\"/static/b5891c01fbeeaf9fbd8417febd57ccac/5a190/change-list.png\"\n        srcset=\"/static/b5891c01fbeeaf9fbd8417febd57ccac/772e8/change-list.png 200w,\n/static/b5891c01fbeeaf9fbd8417febd57ccac/e17e5/change-list.png 400w,\n/static/b5891c01fbeeaf9fbd8417febd57ccac/5a190/change-list.png 800w,\n/static/b5891c01fbeeaf9fbd8417febd57ccac/6da96/change-list.png 922w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h4>3.2. docker container 생성</h4>\n<ul>\n<li>아래부터 진행되는 모든 과정은 docker container 환경에서 테스트를 진행한다. 테스트에 사용한 이미지는 centos8.1 이미지에 postgresql12.3 을 설치하여 테스트 하였다.</li>\n<li>\n<p>master container 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker container run --privileged -d -p <span class=\"token number\">25432</span>:5432 --name <span class=\"token string\">\"master\"</span> gaia3d/mago3d-postgresql /sbin/init</code></pre></div>\n</li>\n<li>\n<p>slave container 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker container run --privileged -d -p <span class=\"token number\">25433</span>:5432 --name <span class=\"token string\">\"slave\"</span> gaia3d/mago3d-postgresql /sbin/init</code></pre></div>\n</li>\n<li>\n<p>container에 연결 하기</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker <span class=\"token builtin class-name\">exec</span> -it master <span class=\"token function\">bash</span></code></pre></div>\n</li>\n</ul>\n<h4>3.3. master 서버 설정</h4>\n<ul>\n<li>master 서버의 설정은 크게 replication role 을 가진 유저를 생성하고, standby 서버가 master 서버에 접근하기 위한 보안 설정과 replication을 위한 설정 3가지로 나눌 수 있다.</li>\n<li>\n<p>replicator 역할의 유저 생성</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">    <span class=\"token function\">su</span> postgres\n    psql -U postgres</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">    <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">USER</span> replicator <span class=\"token keyword\">WITH</span> <span class=\"token keyword\">REPLICATION</span> ENCRYPTED PASSWORD <span class=\"token string\">'secret'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>user가 정상적으로 생성되었는지 확인(\\du)\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9378eb66ac0b5aa26e62eca79a925560/0f79a/user-list.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 689px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 21%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAnklEQVR42k1QwQ6FIAzjJigYREXQYIzhpP//fX3pEsw7NIWtrCvqfV88z4NaK1JKmOcZy7JgXVdhIoQgzF6MEdu2Cf41wzAI1L7vII7jgLUWWmsYY4QJ7/03YBxHdF339ZqWdeqcc1A5Z5RSPkduQEfeG9/3LQlozD51zYS4rksWYhLFAx9QdJ6nnFlrcaZpkqgUk1lvzOHti/q+l8g/U5tjHPCU4+sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"user-list\"\n        title=\"\"\n        src=\"/static/9378eb66ac0b5aa26e62eca79a925560/0f79a/user-list.png\"\n        srcset=\"/static/9378eb66ac0b5aa26e62eca79a925560/772e8/user-list.png 200w,\n/static/9378eb66ac0b5aa26e62eca79a925560/e17e5/user-list.png 400w,\n/static/9378eb66ac0b5aa26e62eca79a925560/0f79a/user-list.png 689w\"\n        sizes=\"(max-width: 689px) 100vw, 689px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n</li>\n<li>\n<p>pg.hba.conf 설정</p>\n<ul>\n<li>type / database / user / address / method(인증방식) 을 작성 후 저장후 postgresql 을 재시작한다.</li>\n<li><strong>address 는 standby 서버의 ip 를 작성하도록 한다.</strong></li>\n<li>\n<p>docker 를 사용해서 테스트 할 경우 container 의 ip 를 작성하도록 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">host</span>    replication     replicator      standbyIP/32             md5</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">systemctl restart postgresql-12</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>postgresql.conf 설정</p>\n<ul>\n<li>\n<p>wal_level(enum)</p>\n<ul>\n<li>WAL 파일에 기록되는 정보의 양을 결정한다. 기본값은 replica 로 WAL 아카이빙(archive mode) 및 streaming replication 을 위해서는 replica 이상을 사용해야 한다.</li>\n<li>9.6 이전 버전에서는 archive, hot_standby 두 값을 쓸 수 있었으며, 12버전에서는 이 설정값을 사용 시 모두 replica로 처리 된다.</li>\n</ul>\n</li>\n<li>\n<p>max<em>wal</em>senders(integer)</p>\n<ul>\n<li>standby 서버 또는 streaming 기본 백업 클라이언트로부터의 최대 동시 연결수를 지정한다. (기본값 : 10)</li>\n<li>이 값이 0일 경우는 replication 이 비활성화 된다.</li>\n<li>일반적으로 standby 서버의 개수 +1 개로 설정한다.</li>\n</ul>\n</li>\n<li>\n<p>wal<em>keep</em>segments(integer)</p>\n<ul>\n<li>standby 서버가 streaming replication을 위해 과거 로그 파일을 가져와야 하는 경우 pg_wal 디렉토리에 저장되는 과거 로그 파일 세그먼트의 최소 수를 지정하며, 각 세그먼트는 일반적으로 16MB 이다.</li>\n<li>wal segment 가 너무 빨리 갱신 되어 빠른 속도로 사라지게 되고, standby 서버에 기록되는 wal segment 가 master 서버의 wal 갱신 속도를 따라가지 못하면 replication이 중단 된다.</li>\n</ul>\n</li>\n<li>\n<p>wal<em>sender</em>timeout(integer)</p>\n<ul>\n<li>\n<p>지정된 시간 이상 작동되지 않은 복제 연결이 중단 된다. 기본값은 60초이고, 0일 경우 비활성화 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">wal_level <span class=\"token operator\">=</span> replica\nmax_wal_senders <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\nwal_keep_segments <span class=\"token operator\">=</span> <span class=\"token number\">32</span>\nwal_sender_timeout <span class=\"token operator\">=</span> 60s</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>설정 파일 저장후 pg 재시작</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">systemctl restart postgresql-12</code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<h4>3.4 Standby 서버 설정</h4>\n<ul>\n<li>pg_basebackup 으로 master db 를 복사할때 옵션을 사용해서 자동으로 replication 설정을 할 수 있다. <strong>ip 는 master 의 ip를 써준다.</strong></li>\n<li>-D : 복사할 data 경로를 지정한다. (postgresql data 파일 경로로 지정해야 한다.)</li>\n<li>-Xs : wal 파일을 stream 방식으로 쓴다.</li>\n<li>-P : 진행사항을 표시한다.</li>\n<li>\n<p><strong>-R : replication 을 위한 설정을 적용한다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">pg_basebackup -h masterIP -U replicator -p <span class=\"token number\">5432</span> -D /pg_data -Xs -P -R</code></pre></div>\n</li>\n<li>\n<p>root 계정으로 복사 했으므로 data 경로의 권한은 postgres로 변경해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chown</span> -R postgres:postgres /pg_data</code></pre></div>\n</li>\n<li>\n<p>standby 서버 실행</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">systemctl start postgresql-12</code></pre></div>\n</li>\n<li>data 폴더에 standby.signal 파일이 있는지와 postgresql.auto.conf 파일에 master 의 정보가 정상적으로 작성되었는지 확인한다.\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a2c1f668ea07582d96af0aceb8bad620/41d3c/standby-signal.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 490px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 87.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACtUlEQVR42nWUSU6bQRCFfwYzCDEZjG0MZrYNeMI2mYeDsAYkFggbJBAsWGAGAwfgDFkhQ6bL5CqV+iqpX7GSLEpd1V31+r2u7g4ODg5kf39fGo2GnJycyPHxcegfHh7K0dGRnJ+fm1+v1+X09NTG7e1t2d3dlZ2dHdnb25OtrS1pt9sSDAwMyODgoEQiERkbG5ORkRHzJycnpa+vT1hfXFy0eHR0VGKxWJjT29trRl4QBHJ2diZBMpmUqakpSSQSksvlpFQqSTablXw+bzY9PS2FQkFWV1dlbm5OMpmM+cVi0WJsYWHBAJvN5i9AwNh5eXlZ1tfXLQFwimdmZgxwdnbWwAEjD4MIquLxuAFeXFxIgJRoNGqAAAFCMQXE+OVyWebn5w0c+fjpdFpSqZTVARoCsqszBAwpKysrJtdlVioVY46/tLRkm5HH8aBkfHy8kyHUJyYmbGfAYEIhMSwodIbOnBi2zjIERL9LhuHa2polwo4YVkj2Yj8/P2OOpIMhSd5plwo7gOk2TDY3N62YcyMHQEbWqeU6hYBIdYYu2ZviMpEMQ/w/5WIA/sUQdhg7elNoArIprlar4UYwxUcBRn1Hlx3sf9cGmUgmxuc4fCSXW9IhGSAk020/O4BgSwFXyhvERqx5Hs2iaR2A3hTvMq8CNhQAxBpzxBQj1wEZ6QFvu6MpGAy94F/3kNgY6hzzxORFtSHI7unultbNjb5lLYjrREylZZRRWV8FY0FB8tqgtBYXVFpOGaU5Cl3LacOKOrdRq0lG7yPrQU+PNFstCTa6uqSm6EWl/FK/oQ/Dw/JCv6a3Q0PyTi37e/5Vf7/UtIj1N/rdfVSZ79Vn7bXGMc170H8xeLy8lEfV/qhfz2fd4dv9vY1f7+7MWGtfXdn88/W1PKss7LvGX25vw/xP+hf+eHqSnxzZJq0Ti007AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"standby-signal\"\n        title=\"\"\n        src=\"/static/a2c1f668ea07582d96af0aceb8bad620/41d3c/standby-signal.png\"\n        srcset=\"/static/a2c1f668ea07582d96af0aceb8bad620/772e8/standby-signal.png 200w,\n/static/a2c1f668ea07582d96af0aceb8bad620/e17e5/standby-signal.png 400w,\n/static/a2c1f668ea07582d96af0aceb8bad620/41d3c/standby-signal.png 490w\"\n        sizes=\"(max-width: 490px) 100vw, 490px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n</ul>\n<h4>3.5 테스트</h4>\n<ul>\n<li>테스트는 master 에 테이블을 하나 생성하고 insert 쿼리 후 standby 서버에 정상적으로 반영이 되는지 확인한다.</li>\n<li>\n<p>master</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">    <span class=\"token function\">su</span> postgres\n    psql -U postgres</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\">    <span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> test <span class=\"token punctuation\">(</span>id <span class=\"token keyword\">serial</span><span class=\"token punctuation\">,</span> name <span class=\"token keyword\">character</span> <span class=\"token keyword\">varying</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> test <span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token string\">'tester'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>\n<p>standby</p>\n<ul>\n<li>\n<p><strong>postgres 9.6 의 경우는 postgresql.conf 파일의 hot_standby 기본 옵션이 ‘off’ 로 되어 있어 psql 사용이 불가능하다. 해당 옵션을 on으로 변경후 pg를 재시작후 테스트를 하도록 한다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">su</span> postgres\npsql -U postgres</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> test<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ul>\n</li>\n</ul>\n<h4>3.6. 모니터링</h4>\n<ul>\n<li>\n<p>master 에서는 walsender 가 standby 에서는 walreceiver 가 잘 실행되고 있는지 확인한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">ps</span> -ef <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> wal</code></pre></div>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/aef5391570648df75f574097c2743f36/14060/wal-check.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 16.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAoUlEQVR42l2LTQ5EQBBGHdKKFqYJdtY2Nlr8dWvEDdzD1d5oM5nFVPLy8lV95VVVRVEUlGVJnueP4zhGSkmWZcg05XXnNEkQUUQQBD/CMHwshMD3feq6xjuOA2MM27ZhrWXfd6ZpQmvNuq5Yhzasd0c77r27O1zf/Tq7fJ4nnvmWlmVhnueHvu8Zx5Gu6z60ik4p2rZF3R6GgaZpuK6L/3kDhrSaCTMDQ2EAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"wal-check\"\n        title=\"\"\n        src=\"/static/aef5391570648df75f574097c2743f36/5a190/wal-check.png\"\n        srcset=\"/static/aef5391570648df75f574097c2743f36/772e8/wal-check.png 200w,\n/static/aef5391570648df75f574097c2743f36/e17e5/wal-check.png 400w,\n/static/aef5391570648df75f574097c2743f36/5a190/wal-check.png 800w,\n/static/aef5391570648df75f574097c2743f36/14060/wal-check.png 949w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n</li>\n<li>master 에서는 pg<em>stat</em>replication 을 standby 에서는 pg<em>stat</em>wal_receiver view를 각각 psql로 조회해본다.\n\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/08fc516e549bb7ec8e827f534fe85c2a/68947/pg-stat.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 800px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 23.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAuklEQVR42l2MSQqEQBAE+wMeXEE9+gR3P+D+EFERRPDp6imHbCiZmUOQUdnVpY7jANn3Hdu2YV1XLMuic55n7eTbBe4I0zThPE8o3/cRhiGCINDQbduGZVlwXVfjeR4cx4Fpmu/8Dd8Mw0AURVD3feN5nh/YCdd1acT/U1zuqGEYMI4jmE3ToG1bDZ30fY+u63RHZ8e5ruu3F2eqoiiQ5zniOEaSJCjLElmWIU1T7aSqqp8k/CMdd+XGBypR2uCNIVw7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px transparent;\"\n        alt=\"pg-stat\"\n        title=\"\"\n        src=\"/static/08fc516e549bb7ec8e827f534fe85c2a/5a190/pg-stat.png\"\n        srcset=\"/static/08fc516e549bb7ec8e827f534fe85c2a/772e8/pg-stat.png 200w,\n/static/08fc516e549bb7ec8e827f534fe85c2a/e17e5/pg-stat.png 400w,\n/static/08fc516e549bb7ec8e827f534fe85c2a/5a190/pg-stat.png 800w,\n/static/08fc516e549bb7ec8e827f534fe85c2a/c1b63/pg-stat.png 1200w,\n/static/08fc516e549bb7ec8e827f534fe85c2a/68947/pg-stat.png 1281w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </li>\n<li>master 서버에서 select pg<em>current</em>wal<em>lsn(); 쿼리 결과의 값이 pg</em>stat<em>replication view 를 조회한 값중 sent</em>lsn 값과 차이가 많이 나면\nmaster 서버가 부하가 많이 걸리거나 네트워크 상황이 좋지 않은 경우이고, standby 서버에서 select pg<em>last</em>wal<em>receive</em>lsn();\n쿼리 결과의 값이 sent_lsn 값과 차이가 많이 나면 standby 서버가 부하가 많이 걸리거나 네트워크 상황이 좋지 않은 경우이다.</li>\n</ul>\n<h3>4. 장애 처리</h3>\n<ul>\n<li>streaming replication 은 수동으로 standby 서버를 master 서버로 승격시켜주고 연결된 application 의 db 접속 정보를 변경해 주어야 한다. 자동 장애 처리를 위해서는 pg-pool2 와 같은 미들웨어를 사용해야 한다.</li>\n<li>\n<p>standby 서버 master 서버로 승격</p>\n<ul>\n<li>\n<p><strong>pg_ctl promote</strong> 호출하거나 postgresql.conf 파일에 <strong>promote<em>trigger</em>file</strong> 파일을 작성하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">su</span> postgres\n./usr/pgsql-12/bin/pg_ctl promote -D /pg_data/</code></pre></div>\n</li>\n<li>data 경로에 standby.siganl 파일이 사라졌는지 확인한다.</li>\n</ul>\n</li>\n<li>\n<p>새로운 master 서버 pg_hba.conf 파일 수정</p>\n<ul>\n<li>\n<p>장애 서버에서 새로운 master 서버의 데이터를 복사하기 위해 장애 서버의 접근을 허용해준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">host</span>    replication     replicator      장애서버IP/32             md5</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">systemctl restart postgresql-12</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>장애 서버 standby 서버로 변경</p>\n<ul>\n<li>\n<p>기존 데이터 디렉토리를 백업하고 pg_basebackup 으로 새로운 master 서버의 DB를 복사한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">mv</span> /pg_data /pg_backup\npg_basebackup -h 새로운masterIP -U replicator -p <span class=\"token number\">5432</span> -D /pg_data  -Xs -P -R</code></pre></div>\n</li>\n<li>\n<p>postgresql 시작</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">systemctl restart postgresql-12</code></pre></div>\n<p>3.5 테스트과정을 반복한다.</p>\n</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/postgresql-high-availability/","prefix":"2020-05-31"},"frontmatter":{"title":"postgreSQL 고가용성","category":"database"}},"authornote":{"id":"265dda60-7971-5464-926f-ea569c79ac0a","html":"<p>🔘 안되면 될 때 까지! 🏃 🔘</p>"}},"pageContext":{"slug":"/postgresql-high-availability/","prev":{"id":"d1daa5a0-3c6f-5f13-930a-eaa2fee5a1a1","fields":{"slug":"/docker-with-centos-postgres/","prefix":"2020-04-26","source":"posts"},"frontmatter":{"title":"centos8 postgresql12&postgis 설치하기","category":"docker"}},"next":{"id":"123193c8-7c13-526c-be01-794f0da6553a","fields":{"slug":"/thymeleaf/","prefix":"2020-06-03","source":"posts"},"frontmatter":{"title":"springBoot Thymeleaf","category":"spring"}},"source":"posts"}},"staticQueryHashes":["960164547","960164547"]}